"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidDeployment = exports.TransactionMinedTimeout = exports.waitAndValidateDeployment = exports.resumeOrDeploy = void 0;
const util_1 = require("util");
const debug_1 = __importDefault(require("./utils/debug"));
const provider_1 = require("./provider");
const sleep = util_1.promisify(setTimeout);
async function resumeOrDeploy(provider, cached, deploy) {
    // If there is a deployment stored, we look its transaction up. If the
    // transaction is found, the deployment is reused.
    if (cached !== undefined) {
        debug_1.default('found previous deployment', cached.txHash);
        const tx = await provider_1.getTransactionByHash(provider, cached.txHash);
        if (tx !== null) {
            debug_1.default('resuming previous deployment', cached.txHash);
            return cached;
        }
        else if (!(await provider_1.isDevelopmentNetwork(provider))) {
            // If the transaction is not found we throw an error, except if we're in
            // a development network then we simply silently redeploy.
            throw new InvalidDeployment(cached);
        }
        else {
            debug_1.default('ignoring invalid deployment in development network', cached.txHash);
        }
    }
    const deployment = await deploy();
    debug_1.default('initiated deployment', deployment.txHash);
    return deployment;
}
exports.resumeOrDeploy = resumeOrDeploy;
async function waitAndValidateDeployment(provider, deployment) {
    const startTime = Date.now();
    // Poll for 60 seconds with a 5 second poll interval.
    // TODO: Make these parameters configurable.
    while (Date.now() - startTime < 60e3) {
        debug_1.default('verifying deployment tx mined', deployment.txHash);
        const tx = await provider_1.getTransactionByHash(provider, deployment.txHash);
        if (tx === null) {
            throw new InvalidDeployment(deployment);
        }
        if (tx.blockHash !== null) {
            debug_1.default('verifying deployment tx succeeded', deployment.txHash);
            const code = await provider_1.getCode(provider, deployment.address);
            if (code === '0x') {
                throw new InvalidDeployment(deployment);
            }
            else {
                return;
            }
        }
        debug_1.default('waiting for deployment tx mined', deployment.txHash);
        await sleep(5e3);
    }
    // A timeout is NOT an InvalidDeployment
    throw new TransactionMinedTimeout(deployment);
}
exports.waitAndValidateDeployment = waitAndValidateDeployment;
class TransactionMinedTimeout extends Error {
    constructor(deployment) {
        super(`Timed out waiting for transaction ${deployment.txHash}`);
        this.deployment = deployment;
    }
}
exports.TransactionMinedTimeout = TransactionMinedTimeout;
class InvalidDeployment extends Error {
    constructor(deployment) {
        super(`Invalid deployment ${deployment.txHash}`);
        this.deployment = deployment;
    }
}
exports.InvalidDeployment = InvalidDeployment;
//# sourceMappingURL=deployment.js.map